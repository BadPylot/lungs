import CoreLocation

// API Key, loaded from Config.plist API_KEY key.
// Stolen from ChatGPT, I know how it works but didn't write it myself
var apiKey: String {
    if let path = Bundle.main.path(forResource: "Config", ofType: "plist"),
       let dict = NSDictionary(contentsOfFile: path) as? [String: AnyObject],
       let key = dict["API_KEY"] as? String {
        return key
    } else {
        fatalError("API key not found in Config.plist")
    }
}

public class QualityModel: Equatable, Hashable, ObservableObject {
    public let first: Bool
    // Whether to show data
    @Published public var hasData = false
    // Whether data is loading
    @Published public var loading = true
    @Published public var city = ""
    @Published public var province = ""
    @Published public var country = ""
    @Published public var aqi = 0
    @Published public var pol = ""
    private var location: CLLocation?
    init(location: CLLocation?, first: Bool) {
        self.first = first
        self.location = location
        Task {
            await updateData()
        }
    }
    public func refresh(newLocation: CLLocation?) {
        if (newLocation != nil) {
            location = newLocation
        }
        Task {
            await updateData()
        }
    }

    @MainActor private func updateData() async {
        loading = true
        if (location == nil || location!.distance(from: CLLocation()) < 1) {
            loading = false
            return
        }
        var components = URLComponents(string: "https://api.airvisual.com/v2/nearest_city")!
        components.queryItems = [
            URLQueryItem(name: "lat", value: "\(location!.coordinate.latitude)"),
            URLQueryItem(name: "lon", value: "\(location!.coordinate.longitude)"),
            URLQueryItem(name: "key", value: "\(apiKey)")
        ]
        var request = URLRequest(url: components.url!, timeoutInterval: Double.infinity)
        request.httpMethod = "GET"
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            let decoder = JSONDecoder()
            do {
                let apiResponse = try decoder.decode(APIResponse.self, from: data)
                if (apiResponse.status != "success" || apiResponse.data.location == nil) {
                    loading = false
                    return
                }
                let body = apiResponse.data
                if body.city != nil {
                    city = body.city!
                }
                if body.state != nil {
                    province = body.state!
                }
                if body.country != nil {
                    country = body.country!
                }
                if body.current?.pollution != nil {
                    aqi = body.current!.pollution.aqius
                    pol = body.current!.pollution.mainus
                }
            } catch {
                print("Failed to decode APIResponse: \(error.localizedDescription)")
            }
        } catch {
            print("Error fetching data: \(error)")
        }
        loading = false
        hasData = true
    }
    // Protocol functions, necessary for SwiftUIPager
    public static func == (lhs: QualityModel, rhs: QualityModel) -> Bool {
        return (lhs.location === rhs.location) && (lhs.first == rhs.first)
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(first)
        hasher.combine(location)
    }
}

// Schema for API response, generated by ChatGPT
struct APIResponse: Codable {
    let status: String
    let data: DataResponse
}

struct DataResponse: Codable {
    let city: String?
    let state: String?
    let country: String?
    let location: Location?
    let current: Current?
}

struct Location: Codable {
    let type: String
    let coordinates: [Double]
}

struct Current: Codable {
    let weather: Weather
    let pollution: Pollution
}

struct Weather: Codable {
    let ts: String
    let tp: Int
    let pr: Int
    let hu: Int
    let ws: Double
    let wd: Int
    let ic: String
}

struct Pollution: Codable {
    let ts: String
    let aqius: Int
    let mainus: String
    let aqicn: Int
    let maincn: String
}
