import CoreLocation

// API Key, loaded from Config.plist API_KEY key.
var apiKey: String {
    if let path = Bundle.main.path(forResource: "Config", ofType: "plist"),
       let dict = NSDictionary(contentsOfFile: path) as? [String: AnyObject],
       let key = dict["API_KEY"] as? String {
        return key
    } else {
        fatalError("API key not found in Config.plist")
    }
}

public class QualityModel: Equatable, Hashable, ObservableObject {
    @Published public var hasData = false
    @Published public var loading = true
    @Published public var city = ""
    @Published public var province = ""
    @Published public var country = ""
    @Published public var aqi = 0
    @Published public var pol = ""
    private var location: CLLocation?
    
    // Default constructor, creates with demo data for Wilmington, NC.
    init() {
        self.location = CLLocation(latitude: 34.210389, longitude: -77.886812)
        self.city = "Wilmington"
        self.province = "NC"
        self.country = "United States"
        self.aqi = 98
        self.pol = "PM5"
        self.hasData = true
        self.loading = false
    }
    
    init(location: CLLocation?) {
        self.location = location
    }
    
    public func refresh(newLocation: CLLocation?) {
        if (newLocation != nil) {
            location = newLocation
        }
        Task {
            await updateData()
        }
    }
    
    @MainActor private func updateData() async {
        loading = true
        if (location == nil || location!.distance(from: CLLocation()) < 1) {
            loading = false
            return
        }
        var components = URLComponents(string: "https://api.airvisual.com/v2/nearest_city")!
        components.queryItems = [
            URLQueryItem(name: "lat", value: "\(location!.coordinate.latitude)"),
            URLQueryItem(name: "lon", value: "\(location!.coordinate.longitude)"),
            URLQueryItem(name: "key", value: "\(apiKey)")
        ]
        var request = URLRequest(url: components.url!, timeoutInterval: 60)
        request.httpMethod = "GET"
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            let decoder = JSONDecoder()
            do {
                let apiResponse = try decoder.decode(APIResponse.self, from: data)
                if (apiResponse.status != "success" || apiResponse.data.location == nil) {
                    print("API error fetching data: \n \(apiResponse)")
                    loading = false
                    return
                }
                let body = apiResponse.data
                if body.city != nil {
                    city = body.city!
                }
                if body.state != nil {
                    province = body.state!
                }
                if body.country != nil {
                    country = body.country!
                }
                if body.current?.pollution != nil {
                    aqi = body.current!.pollution.aqius
                    pol = pollutantName(code: body.current!.pollution.mainus)
                }
            } catch {
                print("Failed to decode APIResponse: \(error.localizedDescription)")
            }
        } catch {
            print("Error fetching data: \(error)")
        }
        loading = false
        hasData = true
    }
    
    private func pollutantName(code: String) -> String {
        switch code {
        case "p1":
            return "PM10"
        case "p2":
            return "PM2.5"
        case "o3":
            return "Ozone O3"
        case "n2":
            return "NO2"
        case "s2":
            return "SO2"
        case "co":
            return "CO"
        default:
            return "Unknown"
        }
    }
    
    public func health() -> String {
        switch aqi {
        case 0...50:
            return "Good"
        case 51...100:
            return "Moderate"
        case 101...150:
            return "Unhealthy for Sensitive Groups"
        case 151...200:
            return "Unhealthy"
        case 201...300:
            return "Very Unhealthy"
        case 301...:
            return "Hazardous"
        default:
            return "Unknown"
        }
    }
    
    // Health description switch, generated by ChatGPT
    public func healthDesc() -> String {
        switch aqi {
        case 0...50:
            return "Air quality is considered satisfactory, and air pollution poses little or no risk."
        case 51...100:
            return "Air quality is acceptable; however, some pollutants may be a concern for a very small number of people who are unusually sensitive to air pollution."
        case 101...150:
            return "Members of sensitive groups may experience health effects. The general public is not likely to be affected. Elderly and those with breathing issues should limit outdoor exposure."
        case 151...200:
            return "Everyone may begin to experience health effects; members of sensitive groups may experience more serious health effects. Limit outdoor exertion."
        case 201...300:
            return "Health alert: everyone may experience more serious health effects. Stay indoors if possible."
        case 301...:
            return "Emergency conditions. The entire population is likely to be affected. Avoid all outdoor activity."
        default:
            return "Unknown AQI value."
        }
    }
    
    // Protocol functions, necessary for SwiftUIPager
    public static func == (lhs: QualityModel, rhs: QualityModel) -> Bool {
        return (lhs.location === rhs.location)
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(location)
    }
}

// Schema for API response, generated by ChatGPT
struct APIResponse: Codable {
    let status: String
    let data: DataResponse
}

struct DataResponse: Codable {
    let message: String?
    let city: String?
    let state: String?
    let country: String?
    let location: Location?
    let current: Current?
}

struct Location: Codable {
    let type: String
    let coordinates: [Double]
}

struct Current: Codable {
    let weather: Weather
    let pollution: Pollution
}

struct Weather: Codable {
    let ts: String
    let tp: Int
    let pr: Int
    let hu: Int
    let ws: Double
    let wd: Int
    let ic: String
}

struct Pollution: Codable {
    let ts: String
    let aqius: Int
    let mainus: String
    let aqicn: Int
    let maincn: String
}
